<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>pnet: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">pnet<span id="projectnumber">&#160;1.1.0</span>
   </div>
   <div id="projectbrief">A petri net library for C/C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">README </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><img src="https://img.shields.io/github/license/Joao-Peterson/pnet" alt="" class="inline"/> <img src="https://img.shields.io/badge/Version-1.1.0-brightgreen" alt="" class="inline"/> <img src="https://img.shields.io/github/last-commit/Joao-Peterson/pnet" alt="" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md0"></a>
pnet - a petri net library for C/C++</h1>
<p >Easily make petri nets in C/C++. This library can create high level timed petri nets, with negated arcs and reset arcs, input events and outputs.</p>
<p >Is intended for embedding!</p>
<p >Licensed under the MIT License. Please reefer to the LICENSE file in the project root for license information.</p>
<p >Documentation available on <a href="https://joao-peterson.github.io/pnet/html/index.html"><b>github pages</b></a>.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
TOC</h1>
<ul>
<li>pnet - a petri net library for C/C++</li>
<li>TOC</li>
<li>Usage<ul>
<li>Arguments<ul>
<li>Weighted arcs</li>
<li>Inhibit arcs</li>
<li>Reset arcs</li>
<li>Input events</li>
<li>Delay</li>
<li>Outputs</li>
<li>Callback</li>
</ul>
</li>
<li>Error handling</li>
</ul>
</li>
<li>Compile and install</li>
<li>Implementation details</li>
<li>TODO</li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
Usage</h1>
<p >To start include the header file:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;pnet.h&quot;</span></div>
</div><!-- fragment --><p >The you can create a new petri net:</p>
<div class="fragment"><div class="line">pnet_t *pnet = pnet_new(</div>
<div class="line">    pnet_arcs_map_new(2,3,</div>
<div class="line">        -1, 0,</div>
<div class="line">         0, 0,</div>
<div class="line">         0, 0</div>
<div class="line">    ),</div>
<div class="line">    pnet_arcs_map_new(2,3,</div>
<div class="line">         0, 0,</div>
<div class="line">         1, 0,</div>
<div class="line">         0, 1</div>
<div class="line">    ),</div>
<div class="line">    pnet_arcs_map_new(2,3,</div>
<div class="line">            0, 1,</div>
<div class="line">            0, 0,</div>
<div class="line">            0, 0</div>
<div class="line">    ),</div>
<div class="line">    pnet_arcs_map_new(2,3,</div>
<div class="line">            0, 0,</div>
<div class="line">            0, 1,</div>
<div class="line">            0, 0</div>
<div class="line">    ),</div>
<div class="line">    pnet_places_init_new(3,</div>
<div class="line">        1, 0, 0</div>
<div class="line">    ),</div>
<div class="line">    pnet_transitions_delay_new(2,</div>
<div class="line">        0, 0</div>
<div class="line">    ),</div>
<div class="line">    pnet_inputs_map_new(2,2,</div>
<div class="line">        pnet_event_none, pnet_event_pos_edge,</div>
<div class="line">        pnet_event_none, pnet_event_none</div>
<div class="line">    ),</div>
<div class="line">    pnet_outputs_map_new(3,3,</div>
<div class="line">        1,0,0,</div>
<div class="line">        0,1,0,</div>
<div class="line">        0,0,1</div>
<div class="line">    ),</div>
<div class="line">    NULL,</div>
<div class="line">    NULL</div>
<div class="line">); </div>
</div><!-- fragment --><p >Note how you can pass weighted arcs, inhibit arcs, reset arcs, the initial tokens for the places, delay for transitions, inputs events and outputs in order, however, only the <code>places_init</code> and <b>at least one</b> type of arc are required, so very simple declarations can be made, like this:</p>
<div class="fragment"><div class="line">pnet_t *pnet = pnet_new(</div>
<div class="line">    pnet_arcs_map_new(1,2,</div>
<div class="line">        -1,</div>
<div class="line">        0</div>
<div class="line">    ),</div>
<div class="line">    pnet_arcs_map_new(1,2,</div>
<div class="line">        0, </div>
<div class="line">        1</div>
<div class="line">    ),</div>
<div class="line">    NULL,</div>
<div class="line">    NULL,</div>
<div class="line">    pnet_places_init_new(2,</div>
<div class="line">        1, 0</div>
<div class="line">    ),</div>
<div class="line">    NULL,</div>
<div class="line">    NULL,</div>
<div class="line">    NULL,</div>
<div class="line">    NULL,</div>
<div class="line">    NULL</div>
<div class="line">);</div>
</div><!-- fragment --><p >To execute your petri net just call <code>pnet_fire</code>:</p>
<div class="fragment"><div class="line">pnet_fire(pnet, pnet_inputs_new(2, 1,0))</div>
</div><!-- fragment --><p >This will execute <b>one and only transition</b> at a time, so the execution is made in stepped manner.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Arguments</h2>
<h3><a class="anchor" id="autotoc_md4"></a>
Weighted arcs</h3>
<p >Weighted arcs define the amount of token that are consumed and given by some transition. Represented in matrix form by two matrices, it's shape should be like:</p>
<div class="fragment"><div class="line">pnet_arcs_map_new(2,3,</div>
<div class="line">    -1, 0,</div>
<div class="line">     0, 0,</div>
<div class="line">     0, 0</div>
<div class="line">),</div>
<div class="line">pnet_arcs_map_new(2,3,</div>
<div class="line">     0, 0,</div>
<div class="line">     1, 0,</div>
<div class="line">     0, 1</div>
<div class="line">),</div>
</div><!-- fragment --><p >The first matrix are the positive weights, the second are the negative weights. Where 2 is the amount of transitions, and 3 the amount of places, notice how the columns represent the transitions and rows the places. In the example we are telling that for the first transition, 1 token will be consumed from the first place, and 1 token will be given to the second place, and for the second transition, a token will be given to the third place.</p>
<p >When there are no negative weights, a transition can fire at any time, so negative weights act as conditions/restrictions for a transition to fire.</p>
<h3><a class="anchor" id="autotoc_md5"></a>
Inhibit arcs</h3>
<p >Inhibit arcs define that a transition shall occur when there are no token in the specified place. Represented in matrix form, values can be only 1 or 0:</p>
<div class="fragment"><div class="line">pnet_arcs_map_new(2,3,</div>
<div class="line">    0, 1,</div>
<div class="line">    0, 0,</div>
<div class="line">    0, 0</div>
<div class="line">),</div>
</div><!-- fragment --><p >In the example we are saying that for the second transition to fire, no tokens can be present in the first place. This type of arc doesn't move any tokens like the reset or weighted arcs, it solely represents a condition, like the negative weights in the weighted arcs.</p>
<h3><a class="anchor" id="autotoc_md6"></a>
Reset arcs</h3>
<p >Reset arcs express the act of setting the number of tokens in a place to 0 if the transition specified is fired. Represented in matrix form, values can be only 1 or 0:</p>
<div class="fragment"><div class="line">pnet_arcs_map_new(2,3,</div>
<div class="line">    0, 0,</div>
<div class="line">    0, 1,</div>
<div class="line">    0, 0</div>
<div class="line">),</div>
</div><!-- fragment --><p >In the example we are saying that the second transition will reset the tokens in the second place when fired. This type of arc expresses change, like the weighted arcs, but no condition/restriction.</p>
<h3><a class="anchor" id="autotoc_md7"></a>
Input events</h3>
<p >Inputs can be passed to <code>pnet_fire</code> and based on the events set by the <code>inputs_map</code> argument in <code>pnet_new</code> can dictate the triggering of transitions.</p>
<p ><code>inputs_map</code> is given in matrix form, only the values of the enumerator <code>pnet_event_t</code> are valid.</p>
<div class="fragment"><div class="line">pnet_inputs_map_new(2,2,</div>
<div class="line">    pnet_event_none, pnet_event_pos_edge,</div>
<div class="line">    pnet_event_none, pnet_event_none</div>
<div class="line">),</div>
</div><!-- fragment --><p >The columns are the transitions and the rows are the inputs.</p>
<p >Only one input event can be assigned to a single transition.</p>
<p ><code>pnet_event_none</code> and 0 are the same.</p>
<p >The events are as follow:</p>
<div class="fragment"><div class="line">pnet_event_none         <span class="comment">// no event, always trigger if arc conditions are met</span></div>
<div class="line">pnet_event_pos_edge     <span class="comment">// when input changes from 0 to 1 between fires</span></div>
<div class="line">pnet_event_neg_edge     <span class="comment">// when input changes from 1 to 0 between fires</span></div>
<div class="line">pnet_event_any_edge     <span class="comment">// when input changes value between fires</span></div>
</div><!-- fragment --><p >Firing can be called with or without inputs:</p>
<div class="fragment"><div class="line">pnet_fire(pnet, pnet_inputs_new(2, 1,0))</div>
</div><!-- fragment --><div class="fragment"><div class="line">pnet_fire(pnet, NULL)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md8"></a>
Delay</h3>
<p >You can add delay to transitions by mapping the value in milliseconds to every transition, a 0 represents a instant transition. Given in matrix form, one row and the columns are the transitions.</p>
<div class="fragment"><div class="line"><span class="comment">// 500 ms delay on transition 0</span></div>
<div class="line">pnet_transitions_delay_new(2,</div>
<div class="line">    500, 0                                                      </div>
<div class="line">),</div>
</div><!-- fragment --><p >Note that when using instant transitions, after the <code>pnet_fire()</code> call, the tokens would have moved already, but when using a delay you can only expect the net state after the define time, so to react accordingly you have to provide a callback, see section Callback. When a callback is given it will be called after a delayed transition is fired.</p>
<h3><a class="anchor" id="autotoc_md9"></a>
Outputs</h3>
<p >Outputs are given in matrix form, values can be only 1 and 0.</p>
<div class="fragment"><div class="line">pnet_outputs_map_new(3,3,</div>
<div class="line">    1,0,0,</div>
<div class="line">    0,1,0,</div>
<div class="line">    0,0,1</div>
<div class="line">)</div>
</div><!-- fragment --><p >The columns are the outputs and the rows are the places. A output is only 1 when there &gt;0 tokens inside the respective place.</p>
<p >The state of the outputs can be accessed reading the <code>outputs</code> member of the <code>pnet_t</code> struct.</p>
<div class="fragment"><div class="line">pnet-&gt;outputs</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md10"></a>
Callback</h3>
<p >A callback of type <code>pnet_callback_t</code> must be provided as argument when using timed transitions. <b>It will</b> be called after the execution of the delay for a given transition and that transition is still sensible. <b>It is also called</b> when a instant transition was fired.</p>
<p >It's form is as follows:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> cb(pnet_t *pnet, <span class="keywordtype">size_t</span> transition, <span class="keywordtype">void</span> *data){</div>
<div class="line">    your_data_struct *my_data = (your_data_struct*)data;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// you code here</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >You can access the pnet directly through the callback as well a user data passed in the <code>data</code> parameter on the <code>pnet_new()</code> and <code>m_pnet_new()</code> calls.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Error handling</h2>
<p >Errors are bound to occur when defining the petri net, we can check for then by comparing the pointer return value from the calls and by using the <code>pnet_get_error</code> and <code>pnet_get_error_msg</code> calls.</p>
<div class="fragment"><div class="line">pnet_t *pnet = pnet_new();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(pnet == NULL || pnet_get_error() != pnet_info_ok){</div>
<div class="line">    <span class="comment">// error handling</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// or </span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(pnet != NULL &amp;&amp; pnet_get_error() == pnet_info_ok){</div>
<div class="line">    <span class="comment">// do petri net stuff </span></div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md12"></a>
Compile and install</h1>
<p >Compilation is done by executing:</p>
<div class="fragment"><div class="line">$ make release</div>
</div><!-- fragment --><p >Installation is done by executing:</p>
<div class="fragment"><div class="line">$ make install</div>
</div><!-- fragment --><p >The location of installation can be configured in the [Makefile](Makefile) by altering the following variables:</p>
<div class="fragment"><div class="line">INSTALL_BIN_DIR</div>
<div class="line">INSTALL_LIB_DIR</div>
<div class="line">INSTALL_INC_DIR</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md13"></a>
Implementation details</h1>
<p >This implementation uses matrix representation and custom independent algorithms by the author for sensing and firing the petri net.</p>
<p >Positive and negative arcs are separated instead of using a single matrix for weighted arcs, that allows for arcs to be defined from a place to that same place, which is intended design/functionality.</p>
<h1><a class="anchor" id="autotoc_md14"></a>
TODO</h1>
<ul>
<li>Prioritized petri net, add priority to transitions</li>
<li>Make special calls for reading the output, or make up another type of abstraction that don't involves matrix_int_t</li>
<li>Callback for output change</li>
<li>Analysis tools</li>
<li>Analysis to highlight mutual firing transitions</li>
<li>PNML support</li>
<li>Better abstraction for embedding purposes</li>
<li>Timed implementation for embedded systems, custom timers</li>
<li>Custom memory allocator option</li>
<li>Compile macro for minimal build, used for excluding some logic checking and abstraction so the library could be compiled for minimal space keeping in mind embedded systems </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
